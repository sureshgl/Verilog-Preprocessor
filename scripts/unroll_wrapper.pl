#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use FindBin qw($Bin);
use FileHandle;
use File::Basename;
use Data::Dumper;
use JSON;
use Cwd;
use Cwd 'realpath';
use IPC::Run3;
use Log::Log4perl qw(:easy);
use Log::Log4perl::Level;

my $opt = {
  'name'         => "",  # cut name
  'sp'           => "",  # starting point, -sp <sp> -sep <cut-core> -ets
  'type'         => "real",
  'enc'          => "",
  'up'           => 0,   #use verilogparser is default
  'lint'         => 0,   # vcs lint
  'sva'          => 1,   # unroll sva or not 
  'lec'          => 1,   # lec is On by default
  'pr'           => 0,   # preserve run directory for debug
  'll'           => 'info',
  'help'         => 0,
  'h'            => 0
};

Log::Log4perl->easy_init( { level   => $INFO,
    file    => "STDOUT",
    layout   => '[%.1p]: %m%n'} );
ALWAYS "cmdline: $0 @ARGV\n";

my $rv = GetOptions ($opt,
  'name=s',
  'sp=s',
  'type=s',
  'enc=s',
  'up!',
  'lint!',
  'lec!',
  'sva!',
  'pr!',
  'll=s',
  'help!',
  'h!'
);

if ( !$rv ||
  !(defined $opt->{'name'})   || ($opt->{'name'} eq '') ||
  $opt->{'h'} ||
  $opt->{'help'}
) {
  print "Usage: $0 -name <cut-name> [-sp <start-module>] [-type real,<beh|func>] [-up] [-nosva] [-nolec] [-enc vcs[,ncv]] [-lint] [-pr] [-h|-help]\n";
  print "   This script runs verilogparser on cut_core_<ver>.v to generate\n";
  print "   unrolled verilog and then runs LEC to compare the input\n";
  print "   verilog and unrolled verilog. It needs to be run from\n";
  print "   run_sample directory generated by memogen.\n";
  print "   -name : cut name\n";
  print "   -up : uses proteus instead of verilogparser \n";
  print "   -sp   : start from this module\n";
  print "   -type : real (default), behavioral (beh) or functional (func) to unroll\n";
  print "   -nolec: do not run LEC (bad idea)\n";
  print "   -enc  : encrypt using any of vcs or ncv\n";
  print "   -lint : run vcs lint checks\n";
  print "   -pr   : to preserve the run directory for debug\n";
  print "   -ll  : log level\n";
  print "   -h    : to print this message\n";
  exit(1);
}
$opt->{'ll'} = uc($opt->{'ll'});
Log::Log4perl->easy_init( { level   => Log::Log4perl::Level::to_priority($opt->{'ll'}),
    file    => "STDOUT",
    layout  => '[%.1p]: %m%n'} );

my $cwd = realpath(getcwd);
my $cfg = {};

my $fi = "./cutinfo/$opt->{'name'}.json";
$cfg->{'frun'} = read_json ($fi);
my $frun = $cfg->{'frun'};
my $sva = $opt->{'sva'} ? "" :"-nosva";
my $lec = $opt->{'lec'} ? "" :"-nolec";
my $type = $opt->{'type'} ? "-type $opt->{'type'}" :"";
my $sp = $opt->{'sp'} ? "-sp $opt->{'sp'}":"";
my $enc = $opt->{'enc'} ? "-enc $opt->{'enc'}":"";
my $lint = $opt->{'lint'} ? "-lint" :"";
my $pr = $opt->{'pr'} ? "-pr" :"";

if($opt->{'up'}){
  my $rv = vsystem(" $cfg->{'frun'}->{'binaryPath'}/../parsers/scripts/proteus_unroll.pl -name $opt->{'name'} $sva $sp $type $lec $enc $lint $pr");
}else {
  my $rv = vsystem(" $cfg->{'frun'}->{'binaryPath'}/../verilogparser/bin/unroll.pl -name $opt->{'name'} $sva $sp $type $lec $enc $lint $pr");
}

sub read_json {
  my $fi = shift;
  ALWAYS "reading $fi";
  my $fh = FileHandle->new( $fi, "r" );
  if ( !defined $fh ) {
    LOGDIE "failed to open $fi for read - regenerate cut if needed\n";
  }
  my @js = <$fh>;
  my $s = join( "\n", @js );
  $fh->close();
  my $jh = decode_json($s);
  return $jh;
}

sub vsystem {
  my $cmd = shift;

  INFO "* $cmd\n";

  my $rv = run3 ($cmd, undef, undef, undef, {'return_if_system_error' => 1});

  my $es   = $?;
  my $en   = $!;
  my $estr = $@;

  if ($rv != 1) {
    LOGDIE "$cmd failed\n";
  }
  if ($es) {
    LOGDIE "$cmd exited with non-zero status : $es : $en : $estr\n";
  }
}

